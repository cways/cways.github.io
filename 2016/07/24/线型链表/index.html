<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>线型链表 | 拾遗</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.2.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.0.0/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">线型链表</h1><a id="logo" href="/.">拾遗</a><p class="description">All time is no time when it is past.</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">线型链表</h1><div class="post-meta">Jul 24, 2016<span> | </span><span class="category"><a href="/categories/数据结构与算法/">数据结构与算法</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><h2 id="1-单向链表"><a href="#1-单向链表" class="headerlink" title="1 单向链表"></a>1 单向链表</h2><p>根据链表的基本定义，我们知道链表的每个节点都是结构一致的，包含数据域和指向下一个节点的指针域。</p>
<p>我们定义ListNode为链表的节点类型，data为数据域，next为索引域：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ListNode</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.data = data; <span class="comment">//数据域</span></div><div class="line">	<span class="keyword">this</span>.next = <span class="literal">null</span>; <span class="comment">//索引域</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和数组通过第一个元素为起始地址进行寻址类似，链表也许呀有一个节点作为起始节点，我们将这个节点定为head，有了它，我们可以通过next域遍历到链表里的所有节点。</p>
<p>我们定义LinkedList为链表类型：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.head = <span class="literal">null</span>;</div><div class="line">	<span class="keyword">this</span>.tail = <span class="literal">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在以上定义中我们还保留了一个tail作为链表最后一个节点的索引。</p>
<p>假定我们需要经常在链表的最后添加节点的话，每次都需要从head开始，遍历所有的节点直到最后一个节点，显然这样的效率很低。而缓存尾节点可以使这一操作在O(0)内完成。</p>
<h2 id="2-链表操作"><a href="#2-链表操作" class="headerlink" title="2 链表操作"></a>2 链表操作</h2><h3 id="2-1-节点查找"><a href="#2-1-节点查找" class="headerlink" title="2.1 节点查找"></a>2.1 节点查找</h3><p>找寻链表中的某个元素很简单，只需要从头节点开始遍历直到找到为止。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//JS实现</span></div><div class="line">LinkedList.prototype.find = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> p=<span class="keyword">this</span>.head;</div><div class="line">	<span class="keyword">while</span>(p!=<span class="literal">null</span> &amp;&amp; p.data!=element)&#123;</div><div class="line">		p=p.next;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> p;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很明显，最坏情况为查找到最后一个节点和要找的元素并不在链表中。平均时间复杂度为O(n)。</p>
<h3 id="2-2-插入"><a href="#2-2-插入" class="headerlink" title="2.2 插入"></a>2.2 插入</h3><h4 id="2-2-1-节点后插入"><a href="#2-2-1-节点后插入" class="headerlink" title="2.2.1 节点后插入"></a>2.2.1 节点后插入</h4><p>在某个节点p后插入，需要把待插入的节点x的next指向p的next节点，然后再把p节点的next指向x即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//JS实现</span></div><div class="line">LinkedList.prototype.insertAfterNode = <span class="function"><span class="keyword">function</span>(<span class="params">element,node</span>)</span>&#123;</div><div class="line">	<span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span>;</div><div class="line">	<span class="keyword">var</span> n=<span class="keyword">new</span> ListNode(element);</div><div class="line">	n.next=node.next;</div><div class="line">	node.next=n;</div><div class="line">	<span class="keyword">if</span>(node==<span class="keyword">this</span>.tail)&#123;</div><div class="line">		<span class="keyword">this</span>.tail=n;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">LinkedList.prototype.insertAfter = <span class="function"><span class="keyword">function</span>(<span class="params">element,data</span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.insertAfterNode(element,<span class="keyword">this</span>.find(data));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-2-2-节点前插入"><a href="#2-2-2-节点前插入" class="headerlink" title="2.2.2 节点前插入"></a>2.2.2 节点前插入</h4><p>节点前插入稍微复杂一些，需要知道该节点前的节点是什么。</p>
<p>我们需要先找该节点之前的节点p，然后对p执行节点后插入。其中存在一个特殊情况就是p是头节点。</p>
<p>我们从头节点开始，分别用prev表示前节点，而cur表示当前节点，每次遍历都使得prev等于上一次的cur，这样prev.next永远指向cur。而cur节点为需要插入的节点时，prev节点就是它前面的节点了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">LinkedList.prototype.findPrevious = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> prev = <span class="literal">null</span>;</div><div class="line">	<span class="keyword">var</span> cur = <span class="keyword">this</span>.head;</div><div class="line">	<span class="keyword">while</span>(cur!=<span class="literal">null</span> &amp;&amp; cur.data!=element)&#123;</div><div class="line">		prev=cur;</div><div class="line">		cur=cur.next;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> [prev,cur];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们把头节点的特殊情况抽象出来。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">LinkedList.prototype.addFirst = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> h = <span class="keyword">new</span> ListNode(element);</div><div class="line">	h.next = <span class="keyword">this</span>.head;</div><div class="line">	<span class="keyword">if</span>( <span class="keyword">this</span>.head==<span class="literal">null</span>)&#123;</div><div class="line">		<span class="keyword">this</span>.tail=h;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">this</span>.head=h;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后是节点前插入：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">LinkedList.prototype.insertBefore = <span class="function"><span class="keyword">function</span>(<span class="params">element,data</span>)</span>&#123;</div><div class="line">	<span class="keyword">if</span>(<span class="keyword">this</span>.head==<span class="literal">null</span>) <span class="keyword">return</span>;</div><div class="line">	<span class="keyword">if</span>(<span class="keyword">this</span>.head.data===data)&#123;</div><div class="line">		<span class="keyword">this</span>.addFirst(element);</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">var</span> p=<span class="keyword">this</span>.findPrevious(data);</div><div class="line">	<span class="keyword">var</span> prev = p[<span class="number">0</span>];</div><div class="line">	<span class="keyword">var</span> cur = p[<span class="number">1</span>];</div><div class="line">	<span class="keyword">if</span>(cur != <span class="literal">null</span>)&#123;</div><div class="line">		<span class="keyword">var</span> n=<span class="keyword">new</span> ListNode(element);</div><div class="line">		prev.next=n;</div><div class="line">		n.next=cur;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>插入的最坏情况为待插入的节点为倒数第二个节点，时间复杂度为O(n)。若已知待插入点，时间复杂度则为O(1)。</p>
<h3 id="2-3-删除"><a href="#2-3-删除" class="headerlink" title="2.3 删除"></a>2.3 删除</h3><p>删除操作根节点后插入的操作正好相反。我们只需要找到待删除的节点p和前一个节点prev，然后将prev的next指向p的next节点即可。特殊情况是待删除的节点为头节点，我们只需要将head指向原head的next即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">LinkedList.prototype.delete = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>)</span>&#123;</div><div class="line">	<span class="keyword">if</span>(tihs.head.data == element)&#123;</div><div class="line">		<span class="keyword">this</span>.head = <span class="keyword">this</span>.headd.next;</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">var</span> p = <span class="keyword">this</span>.findPrevious(element);</div><div class="line">	<span class="keyword">var</span> prev = p[<span class="number">0</span>];</div><div class="line">	<span class="keyword">var</span> cur = p[<span class="number">1</span>];</div><div class="line">	<span class="keyword">if</span>(prev != <span class="literal">null</span> &amp;&amp; cur!=<span class="literal">null</span>)&#123;</div><div class="line">		prev.next = cur.next;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>删除和插入的时间复杂度一致，若已知要删除的节点的前节点，则删除本身的操作时间复杂度为O(1)。</p>
<h3 id="2-4-倒置"><a href="#2-4-倒置" class="headerlink" title="2.4 倒置"></a>2.4 倒置</h3><p>倒置操作是稍微需要点技巧的操作。如果你看到了这里，希望你先考虑一下如何（在线性时间内）实现这个操作。</p>
<p>有一个直观的思路是：遍历整个链表，将每个节点的下一个节点的next域指向自己。</p>
<p>具体的操作为：设当前节点为p，p的next节点为q，每次我们需要将q.next缓存到temp里，然后再将q.next指向p;然后将p移至q的位置，q移至temp的位置，直至q为null。</p>
<p>最后我们需要单独对头节点进行处理，由于倒置，之前的头节点变成了现在尾节点，需要将其next指向null，然后再将头节点指向之前的尾节点，即p。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">LinkedList.prototype.reverse = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> p = <span class="keyword">this</span>.head;</div><div class="line">	<span class="keyword">if</span>(p==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">	<span class="keyword">this</span>.tail = p;</div><div class="line">	<span class="keyword">var</span> tmp,q = q.next;</div><div class="line">	<span class="keyword">while</span>(q!=<span class="literal">null</span>)&#123;</div><div class="line">		tmp = q.next;</div><div class="line">		q.next = p;</div><div class="line">		p = q;</div><div class="line">		q = temp;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">this</span>.head.next = <span class="literal">null</span>;</div><div class="line">	<span class="keyword">this</span>.head = p;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>倒置操作需要遍历整个链表，很显然时间复杂度为O(n)。</p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>通过以上操作，我们知道链表有以下特点：</p>
<ul>
<li>不能直行随机索引查找，只能顺序查找</li>
<li>查找一个元素的时间复杂度为线性级O(n)</li>
<li>在已知待操作的节点时，插入和删除操作的时间复杂度为常量级O(1)</li>
<li>由于每个节点都需要储存下一个节点的索引，所以更加耗费空间 </li>
</ul></div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://cways.github.io/2016/07/24/线型链表/" data-id="cirg34hzk00013ywzzlnfnl7b" class="article-share-link">分享到</a><div class="tags"><a href="/tags/Javascript/">Javascript</a></div><div class="post-nav"><a href="/2016/08/04/CommonJS-AMD-CMD-UMD-md/" class="pre">CommonJS_AMD_CMD_UMD.md</a><a href="/2016/07/13/使用MyBatis-Generator自动创建代码/" class="next">使用MyBatis Generator自动创建代码</a></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://cways.github.io"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Javascript/">-Javascript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mybatis/">Mybatis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构与算法/">数据结构与算法</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Javascript/" style="font-size: 15px">-Javascript</a> <a href="/tags/Javascript/" style="font-size: 15px">Javascript</a> <a href="/tags/JAVA/" style="font-size: 15px">JAVA</a> <a href="/tags/MyBatis/" style="font-size: 15px">MyBatis</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/08/04/CommonJS-AMD-CMD-UMD-md/">CommonJS_AMD_CMD_UMD.md</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/24/线型链表/">线型链表</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/13/使用MyBatis-Generator自动创建代码/">使用MyBatis Generator自动创建代码</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/12/hello-world/">Hello World</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">拾遗.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>